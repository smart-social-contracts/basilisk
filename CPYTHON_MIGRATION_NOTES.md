# CPython Backend Migration Notes

This document records the design decisions, fixes, and open items for the CPython backend
(`BASILISK_PYTHON_BACKEND=cpython`), which replaces the RustPython interpreter with CPython 3.13
compiled to `wasm32-wasip1`.

## Overview

| Aspect | RustPython (default) | CPython |
|--------|---------------------|---------|
| Interpreter | RustPython (Rust, compiled to wasm) | CPython 3.13 (C, cross-compiled to wasm32-wasip1) |
| FFI crate | `rustpython`, `rustpython-vm` | `basilisk_cpython` |
| Build artifact | — | `libpython3.13.a` (~38 MB static lib) |
| Expected speedup | baseline | 7–20× |

## How to build

```bash
export BASILISK_PYTHON_BACKEND=cpython
python -m basilisk <canister_name>
```

Prerequisites (installed once):
- Rust toolchain with `wasm32-wasip1` target
- WASI SDK (tested with 25.0)
- CPython 3.13 built for `wasm32-wasip1` (see `compiler/cpython/install_cpython_wasm.sh`)
- `wasi2ic` and `candid-extractor` cargo tools

## Architecture

### Code generation dispatch

The env var `BASILISK_PYTHON_BACKEND` is read in two places:
1. **`basilisk_generate`** (code generator binary) — `backend.rs` checks the var and dispatches
   to `cpython_*` modules for header, body, vm_value_conversion, IC object, canister methods.
2. **`basilisk_vm_value_derive`** (proc-macro crate) — `lib.rs` checks the var at macro-expansion
   time and emits CPython-specific derive implementations.

### basilisk_cpython crate

`basilisk/compiler/basilisk_cpython/` provides a safe Rust API over CPython's C API:

| RustPython type | basilisk_cpython equivalent |
|---|---|
| `rustpython_vm::Interpreter` | `Interpreter` |
| `rustpython_vm::scope::Scope` | `Scope` |
| `rustpython::vm::PyObjectRef` | `PyObjectRef` |
| `rustpython_vm::builtins::PyBaseExceptionRef` | `PyError` |
| `vm.ctx.new_dict()` | `PyDict::new()` |
| `vm.ctx.new_tuple(vec![...])` | `PyTuple::new(vec![...])` |

### IC object

RustPython uses `#[pyclass]` to expose IC functions to Python. CPython uses a C extension module
(`_basilisk_ic`) generated by `cpython_ic_object/`. The Python-side `basilisk` module imports
from `_basilisk_ic` transparently.

## Fixes applied during E2E proof of concept

### 1. `basilisk_cpython` crate compilation

| File | Issue | Fix |
|------|-------|-----|
| `interpreter.rs` | `{source!r}` is Python format syntax inside Rust `format!` | Added `python_repr()` helper function |
| `convert.rs` | `Vec<u8>` specific impl conflicts with generic `Vec<T>` impl | Removed specific `Vec<u8>` impls for `TryIntoPyObject`/`TryFromPyObject`; the codegen layer handles bytes via `CdkActTryIntoVmValue` |
| `object.rs` | Unused `c_int` import | Removed |

### 2. Generated code compilation

| File | Issue | Fix |
|------|-------|-----|
| `cpython_vm_value_conversion/try_into_vm_value_impls.rs` | Missing `BasiliskTryIntoVec` trait definition | Copied trait + all impls from RustPython `vec.rs` |
| `cpython_vm_value_conversion/try_into_vm_value_impls.rs` | Function named `cpython_try_into_vm_value_generic_array` but derive macros call `try_into_vm_value_generic_array(self, ())` | Renamed function, added `_: ()` context parameter |
| `cpython_vm_value_conversion/try_from_vm_value_impls.rs` | Same naming mismatch for `try_from` variant | Same fix |
| `cpython_ic_object/functions/with_args.rs` | `s.parse::<candid::IDLArgs>()` — `IDLArgs` doesn't impl `FromStr` | Changed to `candid_parser::parse_idl_args(&s)` |
| `cpython_header/use_statements.rs` | Imported `basilisk_cpython::UnwrapOrTrap` conflicting with locally generated `UnwrapOrTrap` trait | Removed the import |
| `cpython_canister_method/init_method.rs` | `panic!("{}", err)` where err is `(RejectionCode, String)` (no Display impl) | Changed to `panic!("{:?}", err)` |
| `canister_method/init_method/rust.rs` | Same `panic!` issue | Same fix |
| `cargotoml.py` | Missing `num-bigint` direct dependency for CPython Cargo.toml | Added `num-bigint = "0.4"` |

### 3. External dependency workaround

**`cdk_framework` generates `panic!(err)`** (deprecated Rust syntax) in `act/random.rs`.
Cannot patch the git dependency directly (cargo re-fetches). Added a post-generation fixup in
`__main__.py` (`fixup_generated_code()`) that replaces `panic!(err)` → `panic!("{:?}", err)` in
the generated `lib.rs`.

### 4. Linking

**WASI sysroot library path**: `build.rs` now searches for WASI emulated libraries
(`libwasi-emulated-signal.a`, etc.) in `WASI_SDK_PATH` or common install locations
(`~/.local/share/wasi-sdk/`, `/opt/wasi-sdk/`).

### 5. Unresolved wasm imports (stubs)

CPython's `libpython3.13.a` statically links several extension modules that reference
external C libraries not available on the IC:

| Module | Symbols | Count |
|--------|---------|-------|
| `_decimal` (mpdecimal) | `mpd_*` | ~100 |
| `pyexpat` (expat XML) | `PyExpat_XML_*` | ~50 |
| `_hashlib` (HACL*) | `python_hashlib_Hacl_*` | ~12 |
| `dlopen` | `dlopen`, `dlsym`, `dlerror` | 3 |
| CPython API | `PyModule_Create` | 1 |

**Temporary fix**: `wasm_stubs.rs` provides `#[no_mangle] extern "C"` no-op stubs that resolve
at link time. These are never called at runtime for typical canister workloads.

**Proper fix** (TODO): Rebuild CPython with these modules disabled in `Modules/Setup.local`:
```
*disabled*
_decimal
pyexpat
_hashlib
```

### 6. Candid interface generation

`candid-extractor` executes the wasm binary to extract the Candid interface. For CPython builds,
the WASI reactor initialization calls `ic_cdk::api::time()` which isn't available in wasmtime.

**Fix**: `generate_candid_file_from_source()` in `build_wasm_binary_or_exit.py` parses the
generated Rust source for `#[candid::candid_method]` annotations and generates the `.did` file
directly, bypassing `candid-extractor`.

**Limitation**: The source-based parser handles basic Candid types but may need extension for
complex user-defined types (Records, Variants). For those, the type definitions would need to
be extracted from the Python AST or the generated Rust structs.

## Open items

1. **Rebuild CPython with modules disabled** — eliminates need for `wasm_stubs.rs`
2. **Pre-built CPython wasm artifacts in CI** — avoid 30-min cross-compilation per developer
3. **dfx deploy + runtime test** — verify the canister actually responds to queries
4. **Performance benchmarking** — measure CPython vs RustPython on IC workloads
5. **Complex type Candid generation** — extend source-based `.did` generator for Records/Variants
6. **Fork/patch cdk_framework** — fix `panic!(err)` upstream instead of post-generation fixup
